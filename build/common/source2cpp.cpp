
#include <common/debug_unordered_map.h>
#include <common/debug_string.h>
#include <utility>
#include <stdexcept>

static const uts::unordered_map<uts::string, uts::string> g_sources{

    std::pair<uts::string, uts::string>("basic.vert",
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "// vertex shader: basicShader; simple Phong Model lighting\n"
        "\n"
        "layout (location=0) in vec3 vertex;\n"
        "layout (location=1) in vec2 UV;\n"
        "\n"
        "// transformations\n"
        "uniform mat4 MV; // model-view mx\n"
        "uniform mat4 MVproj; //model-view-projection mx\n"
        "uniform mat3 normMx; // normal matrix\n"
        "\n"
        "//colours and material\n"
        "uniform vec4 matDiffuse;\n"
        "uniform vec4 matAmbient;\n"
        "uniform vec4 lightpos; // in camera space\n"
        "uniform vec4 diffuseCol;\n"
        "uniform vec4 ambientCol;\n"
        "\n"
        "uniform sampler2D normalMap;\n"
        "uniform sampler2D htMap;\n"
        "\n"
        "uniform int drawWalls; // if 0, draw terrain, else drawing walls\n"
        "uniform vec3 normalWall; // if drawing wall vertices, use this normal\n"
        "\n"
        "out vec3 normal; // vertex normal\n"
        "out vec3 lightDir; // toLight\n"
        "out vec3 halfVector;\n"
        "out vec4 diffuse;\n"
        "out vec4 ambient;\n"
        "\n"
        "out vec3 pos;\n"
        "out vec2 texCoord;\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "    vec3 inNormal, v;\n"
        "\n"
        "\n"
        "    texCoord = UV;\n"
        "    v = vertex;\n"
        "\n"
        "    // lookup normal in texture\n"
        "    if (drawWalls == 0) // drawing ht field - lookup normals\n"
        "    {\n"
        "        inNormal = texture(normalMap, UV).xyz;\n"
        "        // correct vertex position from heigt map...\n"
        "        v.y = texture(htMap, UV).r;\n"
        "\n"
        "    }\n"
        "    else\n"
        "    {\n"
        "        inNormal = normalWall; // use fixed normal for all wall vertices\n"
        "        if (UV.s < 0.0) // base of wall: leave at z=0.0\n"
        "            v.y = 0.0;\n"
        "        else\n"
        "            v.y = texture(htMap, UV).r;\n"
        "\n"
        "    }\n"
        "\n"
        "    pos = v;\n"
        "\n"
        "    // map to camera space for lighting etc\n"
        "    normal = normalize(normMx * inNormal);\n"
        "\n"
        "\n"
        "    // vertex in camera coords\n"
        "    vec4 ecPos = MV * vec4(v, 1.0);\n"
        "\n"
        "    lightDir  = normalize(lightpos.xyz - ecPos.xyz);\n"
        "\n"
        "    halfVector = normalize(normalize(-ecPos.xyz) + lightDir);\n"
        "\n"
        "    diffuse = matDiffuse * diffuseCol;\n"
        "    ambient = matAmbient * ambientCol;\n"
        "\n"
        "    gl_Position = MVproj * vec4(v, 1.0); // clip space position\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("basic.frag",
        "#version 150\n"
        "\n"
        "uniform vec4 specularCol;\n"
        "uniform float shiny;\n"
        "uniform vec4 matSpec;\n"
        "\n"
        "uniform int drawWalls;\n"
        "uniform int useRegionTexture;\n"
        "uniform int drawContours;\n"
        "\n"
        "uniform sampler2D overlayTexture;\n"
        "\n"
        "in vec3 pos;\n"
        "in vec2 texCoord;\n"
        "\n"
        "in vec3 normal;\n"
        "in vec3 halfVector;\n"
        "in vec3 lightDir;\n"
        "in vec4 diffuse;\n"
        "in vec4 ambient;\n"
        "\n"
        "out vec4 color;\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "\n"
        "    vec3 n, halfV,viewV,ldir;\n"
        "    vec4 Diff;\n"
        "    float NdotL,NdotHV;\n"
        "    color = ambient; //global ambient\n"
        "    //float att;\n"
        "\n"
        "    // use textur emap for diffuse colour if terrain overlay is present\n"
        "\n"
        "    Diff = (useRegionTexture == 1 ? texture(overlayTexture, texCoord) : diffuse);\n"
        "    n = normalize(normal);\n"
        "\n"
        "    //compute the dot product between normal and normalized lightdir\n"
        "\n"
        "    NdotL = dot(n, normalize(lightDir));\n"
        "\n"
        "    if (NdotL > 0.0) {\n"
        "\n"
        "        //att = 1.0 / (gl_LightSource[0].constantAttenuation +\n"
        "        //    gl_LightSource[0].linearAttenuation * dist +\n"
        "        //    gl_LightSource[0].quadraticAttenuation * dist * dist);\n"
        "        //color += att * (Diff * NdotL + ambient);\n"
        "        color += Diff * NdotL;\n"
        "\n"
        "        halfV = normalize(halfVector);\n"
        "        NdotHV = max(dot(n,halfV), 0.0);\n"
        "        //color += att * gl_FrontMaterial.specular * gl_LightSource[0].specular *\n"
        "        //pow(NdotHV,gl_FrontMaterial.shininess);\n"
        "        color += matSpec * specularCol * pow(NdotHV, shiny);\n"
        "        }\n"
        "\n"
        "    // draw contours\n"
        "\n"
        "    if (drawContours == 1)\n"
        "    {\n"
        "        float f  = abs(fract (pos.y*70) - 0.5);\n"
        "        float df = fwidth(pos.y*70);\n"
        "        float g = smoothstep(-1.0*df, 1.0*df , f);\n"
        "\n"
        "        float c = g;\n"
        "        color = vec4(c,c,c,1.0) * color + (1-c)*vec4(1.0,0.0,0.0,1.0);\n"
        "    }\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("genNormal.vert",
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "// vertex shader: genNormals\n"
        "layout (location=0) in vec2 vertex;\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "    gl_Position = vec4(vertex.x, vertex.y, 0.0, 1.0); // already in clip space for ortho cam\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("genNormal.frag",
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "// fragment shader: gennormal\n"
        "out vec4 norm;\n"
        "\n"
        "uniform vec2 imgSize;\n"
        "uniform sampler2D htMap;\n"
        "\n"
        "uniform vec2 scale;\n"
        "\n"
        "// NB!!! y and z have been swapped: y is now height above (x,z) base plane.\n"
        "// F = (x, f(x,z), z); need dF/dx and dF/dz to define base vectors for cross product\n"
        "// dF/dx = (1, df/dx,0); dF/dz = (0, df/dz, 1)\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "    vec2  pos, delta;\n"
        "\n"
        "    // const float scale = 10.0*1024.0; // should be passed as parameter\n"
        "\n"
        "    vec3 dfdx = vec3(1.0, 0.0, 0.0), // df/dx and df/dy used to define normal\n"
        "         dfdy = vec3(0.0, 0.0, 1.0); // y component filled in below\n"
        "\n"
        "    delta.x = 1.0f/imgSize.x;\n"
        "    delta.y = 1.0f/imgSize.y;\n"
        "\n"
        "    pos = (gl_FragCoord.xy + 0.5 ) / imgSize.xy;\n"
        "\n"
        "    dfdx.y = (texture(htMap, vec2(pos.x+delta.x, pos.y)).r/scale.x -\n"
        "              texture(htMap, vec2(pos.x-delta.x, pos.y) ).r/scale.x)/(2.0*delta.x);\n"
        "    dfdy.y = (texture(htMap, vec2(pos.x, pos.y+delta.y) ).r/scale.y -\n"
        "              texture(htMap, vec2(pos.x, pos.y-delta.y) ).r/scale.y)/(2.0*delta.y);\n"
        "\n"
        "\n"
        "    /*\n"
        "\n"
        "    pos = gl_FragCoord.xy;\n"
        "\n"
        "    ivec2 p = ivec2(pos);\n"
        "\n"
        "    dfdx.z = (texelFetch(htMap, ivec2(p.x+1, p.y), 0 ).r -\n"
        "              texelFetch(htMap, ivec2(p.x-1, p.y), 0 ).r)/(0.004);\n"
        "    dfdy.z = (texelFetch(htMap, ivec2(p.x, p.y+1), 0 ).r -\n"
        "              texelFetch(htMap, ivec2(p.x, p.y-1), 0 ).r)/(0.004);\n"
        "    */\n"
        "\n"
        "    vec3 n = -cross(dfdx, dfdy);\n"
        "\n"
        "//  n = vec3(0.0, 1.0, 0.0);\n"
        "    norm = vec4(normalize(n), 0.0);\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("simple.vert",
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "layout (location=0) in vec4 vertex;\n"
        "\n"
        "void main( void )\n"
        "{\n"
        "    gl_Position = vertex;\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("simple.frag",
        "#version 150\n"
        "\n"
        "//layout(location = 0, index = 0)\n"
        "out vec4 fragColor;\n"
        "\n"
        "void main( void )\n"
        "{\n"
        "    fragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("phong.vert",
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "// vertex shader: basicShader; simple Phong Model lighting\n"
        "\n"
        "layout (location=0) in vec3 vertex;\n"
        "layout (location=1) in vec2 UV;\n"
        "layout (location=2) in vec3 vertexNormal;\n"
        "\n"
        "// transformations\n"
        "uniform mat4 MV; // model-view mx\n"
        "uniform mat4 MVproj; //model-view-projection mx\n"
        "uniform mat3 normMx; // normal matrix\n"
        "\n"
        "//colours and material\n"
        "uniform vec4 matDiffuse;\n"
        "uniform vec4 matAmbient;\n"
        "uniform vec4 lightpos; // in camera space\n"
        "uniform vec4 diffuseCol;\n"
        "uniform vec4 ambientCol;\n"
        "\n"
        "// per pixel values to be computed in fragment shader\n"
        "out vec3 normal; // vertex normal\n"
        "out vec3 lightDir; // toLight\n"
        "out vec3 halfVector;\n"
        "out vec4 diffuse;\n"
        "out vec4 ambient;\n"
        "\n"
        "out vec2 texCoord;\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "    vec3 inNormal, v;\n"
        "\n"
        "    texCoord = UV;\n"
        "    v = vertex;\n"
        "    inNormal = vertexNormal;\n"
        "\n"
        "    // map to camera space for lighting etc\n"
        "    normal = normalize(normMx * inNormal);\n"
        "\n"
        "    // vertex in camera coords\n"
        "    vec4 ecPos = MV * vec4(v, 1.0);\n"
        "\n"
        "    lightDir  = normalize(lightpos.xyz - ecPos.xyz);\n"
        "    halfVector = normalize(normalize(-ecPos.xyz) + lightDir);\n"
        "\n"
        "    diffuse = matDiffuse * diffuseCol;\n"
        "    ambient = matAmbient * ambientCol;\n"
        "\n"
        "    gl_Position = MVproj * vec4(v, 1.0); // clip space position\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("phong.frag",
        "#version 150\n"
        "\n"
        "uniform vec4 specularCol;\n"
        "uniform float shiny;\n"
        "uniform vec4 matSpec;\n"
        "\n"
        "in vec2 texCoord;\n"
        "\n"
        "in vec3 normal;\n"
        "in vec3 halfVector;\n"
        "in vec3 lightDir;\n"
        "in vec4 diffuse;\n"
        "in vec4 ambient;\n"
        "\n"
        "out vec4 color;\n"
        "\n"
        "// NOTE: this shader does not compute a disance attentuation term for lighting.\n"
        "// some more variables need to be passed in for that.\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "\n"
        "    vec3 n, halfV,viewV,ldir;\n"
        "    float NdotL,NdotHV;\n"
        "    color = ambient; //global ambient\n"
        "    //float att;\n"
        "\n"
        "    n = normalize(normal);\n"
        "\n"
        "    //compute the dot product between normal and normalized lightdir\n"
        "\n"
        "    NdotL = max(dot(n, normalize(lightDir)), 0.0);\n"
        "\n"
        "    if (NdotL >= 0.0) {\n"
        "\n"
        "        //att = 1.0 / (gl_LightSource[0].constantAttenuation +\n"
        "        //    gl_LightSource[0].linearAttenuation * dist +\n"
        "        //    gl_LightSource[0].quadraticAttenuation * dist * dist);\n"
        "        //color += att * (diffuse * NdotL + ambient);\n"
        "        color += diffuse * NdotL; // + ambient;\n"
        "\n"
        "        halfV = normalize(halfVector);\n"
        "        NdotHV = max(dot(n,halfV),0.0);\n"
        "        //color += att * gl_FrontMaterial.specular * gl_LightSource[0].specular *\n"
        "        //pow(NdotHV,gl_FrontMaterial.shininess);\n"
        "        color += matSpec * specularCol * pow(NdotHV, shiny);\n"
        "        }\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("phongRS.vert",
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "// vertex shader: basicShader; simple Phong Model lighting\n"
        "\n"
        "layout (location=0) in vec3 vertex;\n"
        "layout (location=1) in vec2 UV;\n"
        "layout (location=2) in vec3 vertexNormal;\n"
        "\n"
        "// transformations\n"
        "uniform mat4 MV; // model-view mx\n"
        "uniform mat4 MVproj; //model-view-projection mx\n"
        "uniform mat3 normMx; // normal matrix\n"
        "\n"
        "//colours and material\n"
        "uniform vec4 matDiffuse;\n"
        "uniform vec4 matAmbient;\n"
        "uniform vec4 lightpos; // in camera space\n"
        "uniform vec4 diffuseCol;\n"
        "uniform vec4 ambientCol;\n"
        "\n"
        "// per pixel values to be computed in fragment shader\n"
        "out vec3 normal; // vertex normal\n"
        "out vec3 lightDir; // toLight\n"
        "out vec3 halfVector;\n"
        "out vec4 diffuse;\n"
        "out vec4 ambient;\n"
        "\n"
        "out vec2 texCoord;\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "    vec3 inNormal, v;\n"
        "\n"
        "    texCoord = UV;\n"
        "    v = vertex;\n"
        "    inNormal = vertexNormal;\n"
        "\n"
        "    // map to camera space for lighting etc\n"
        "    normal = normalize(normMx * inNormal);\n"
        "\n"
        "    // vertex in camera coords\n"
        "    vec4 ecPos = MV * vec4(v, 1.0);\n"
        "\n"
        "    lightDir  = normalize(lightpos.xyz - ecPos.xyz);\n"
        "    halfVector = normalize(normalize(-ecPos.xyz) + lightDir);\n"
        "\n"
        "    diffuse = matDiffuse * diffuseCol;\n"
        "    ambient = matAmbient * ambientCol;\n"
        "\n"
        "    gl_Position = MVproj * vec4(v, 1.0); // clip space position\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("phongRS.frag",
        "#version 150\n"
        "\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "uniform vec4 specularCol;\n"
        "uniform float shiny;\n"
        "uniform vec4 matSpec;\n"
        "\n"
        "uniform int drawWalls;\n"
        "uniform sampler2D decalTexture;\n"
        "uniform int useTexturing;\n"
        "\n"
        "layout (location = 0) out vec4 grad;\n"
        "layout (location = 1) out vec4 norm;\n"
        "layout (location = 2) out vec4 color;\n"
        "\n"
        "in vec3 normal;\n"
        "in vec3 halfVector;\n"
        "in vec3 lightDir;\n"
        "in vec4 diffuse;\n"
        "in vec4 ambient;\n"
        "\n"
        "in vec2 texCoord;\n"
        "\n"
        "// NOTE: this shader does not compute a disance attentuation term for lighting.\n"
        "// some more variables need to be passed in for that.\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "\n"
        "    vec3 n, halfV,viewV,ldir;\n"
        "    float NdotL,NdotHV;\n"
        "    color = ambient; //global ambient\n"
        "    //float att;\n"
        "\n"
        "    n = normalize(normal);\n"
        "\n"
        "    //compute the dot product between normal and normalized lightdir\n"
        "\n"
        "    NdotL = max(dot(n, normalize(lightDir)), 0.0);\n"
        "\n"
        "    if (NdotL > 0.0) {\n"
        "\n"
        "        //att = 1.0 / (gl_LightSource[0].constantAttenuation +\n"
        "        //    gl_LightSource[0].linearAttenuation * dist +\n"
        "        //    gl_LightSource[0].quadraticAttenuation * dist * dist);\n"
        "        //color += att * (diffuse * NdotL + ambient);\n"
        "        color += diffuse * NdotL; // + ambient;\n"
        "\n"
        "        halfV = normalize(halfVector);\n"
        "        NdotHV = max(dot(n,halfV),0.0);\n"
        "        //color += att * gl_FrontMaterial.specular * gl_LightSource[0].specular *\n"
        "        //pow(NdotHV,gl_FrontMaterial.shininess);\n"
        "        color += matSpec * specularCol * pow(NdotHV, shiny);\n"
        "\n"
        "     }\n"
        "     // decal texturing:\n"
        "     if (useTexturing == 1)\n"
        "     {\n"
        "        vec4 texel = texture(decalTexture, texCoord);\n"
        "        // color = vec4(texCoord.x, texCoord.y, 0.0, 1.0);\n"
        "        // color = vec4(texel.r, texel.g, texel.b, color.a); // GL_REPLACE\n"
        "        color = vec4(mix(color.rgb, texel.rgb, texel.a), color.a); // GL_DECAL\n"
        "     }\n"
        "     norm = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("phongRSmanip.vert",
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "// vertex shader: basicShader; simple Phong Model lighting\n"
        "\n"
        "layout (location=0) in vec3 vertex;\n"
        "layout (location=1) in vec2 UV;\n"
        "layout (location=2) in vec3 vertexNormal;\n"
        "\n"
        "// transformations\n"
        "uniform mat4 MV; // model-view mx\n"
        "uniform mat4 MVproj; //model-view-projection mx\n"
        "uniform mat3 normMx; // normal matrix\n"
        "\n"
        "//colours and material\n"
        "uniform vec4 matDiffuse;\n"
        "uniform vec4 matAmbient;\n"
        "uniform vec4 lightpos; // in camera space\n"
        "uniform vec4 diffuseCol;\n"
        "uniform vec4 ambientCol;\n"
        "\n"
        "// per pixel values to be computed in fragment shader\n"
        "out vec3 normal; // vertex normal\n"
        "out vec3 lightDir; // toLight\n"
        "out vec3 halfVector;\n"
        "out vec4 diffuse;\n"
        "out vec4 ambient;\n"
        "\n"
        "out vec2 texCoord;\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "    vec3 inNormal, v;\n"
        "\n"
        "    texCoord = UV;\n"
        "    v = vertex;\n"
        "    inNormal = vertexNormal;\n"
        "\n"
        "    // map to camera space for lighting etc\n"
        "    normal = normalize(normMx * inNormal);\n"
        "\n"
        "    // vertex in camera coords\n"
        "    vec4 ecPos = MV * vec4(v, 1.0);\n"
        "\n"
        "    lightDir  = normalize(lightpos.xyz - ecPos.xyz);\n"
        "    halfVector = normalize(normalize(-ecPos.xyz) + lightDir);\n"
        "\n"
        "    diffuse = matDiffuse * diffuseCol;\n"
        "    ambient = matAmbient * ambientCol;\n"
        "\n"
        "    gl_Position = MVproj * vec4(v, 1.0); // clip space position\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("phongRSmanip.frag",
        "#version 150\n"
        "\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "uniform vec4 specularCol;\n"
        "uniform float shiny;\n"
        "uniform vec4 matSpec;\n"
        "\n"
        "uniform int drawWalls;\n"
        "uniform sampler2D decalTexture;\n"
        "uniform int useTexturing;\n"
        "\n"
        "uniform float manipAlpha;\n"
        "\n"
        "layout (location = 0) out vec4 color;\n"
        "\n"
        "in vec3 normal;\n"
        "in vec3 halfVector;\n"
        "in vec3 lightDir;\n"
        "in vec4 diffuse;\n"
        "in vec4 ambient;\n"
        "\n"
        "in vec2 texCoord;\n"
        "\n"
        "// NOTE: this shader does not compute a disance attentuation term for lighting.\n"
        "// some more variables need to be passed in for that.\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "\n"
        "    vec3 n, halfV,viewV,ldir;\n"
        "    float NdotL,NdotHV;\n"
        "    color = ambient; //global ambient\n"
        "    //float att;\n"
        "\n"
        "    n = normalize(normal);\n"
        "\n"
        "    //compute the dot product between normal and normalized lightdir\n"
        "\n"
        "    NdotL = max(dot(n, normalize(lightDir)), 0.0);\n"
        "\n"
        "    if (NdotL > 0.0) {\n"
        "\n"
        "        //att = 1.0 / (gl_LightSource[0].constantAttenuation +\n"
        "        //    gl_LightSource[0].linearAttenuation * dist +\n"
        "        //    gl_LightSource[0].quadraticAttenuation * dist * dist);\n"
        "        //color += att * (diffuse * NdotL + ambient);\n"
        "        color += diffuse * NdotL; // + ambient;\n"
        "\n"
        "        halfV = normalize(halfVector);\n"
        "        NdotHV = max(dot(n,halfV),0.0);\n"
        "        //color += att * gl_FrontMaterial.specular * gl_LightSource[0].specular *\n"
        "        //pow(NdotHV,gl_FrontMaterial.shininess);\n"
        "        color += matSpec * specularCol * pow(NdotHV, shiny);\n"
        "\n"
        "     }\n"
        "     // decal texturing:\n"
        "     if (useTexturing == 1)\n"
        "     {\n"
        "        vec4 texel = texture(decalTexture, texCoord);\n"
        "        // color = vec4(texCoord.x, texCoord.y, 0.0, 1.0);\n"
        "        // color = vec4(texel.r, texel.g, texel.b, color.a); // GL_REPLACE\n"
        "        color = vec4(mix(color.rgb, texel.rgb, texel.a), color.a); // GL_DECAL\n"
        "     }\n"
        "\n"
        "     color.a = manipAlpha; // override this for all produced fragments\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("rad_scaling_pass1.vert",
        "/****************************************************************************\n"
        "* Render Radiance Scaling                                                   *\n"
        "* Meshlab's plugin                                                          *\n"
        "*                                                                           *\n"
        "* Copyright(C) 2010                                                         *\n"
        "* Vergne Romain, Dumas Olivier                                              *\n"
        "* INRIA - Institut Nationnal de Recherche en Informatique et Automatique    *\n"
        "*                                                                           *\n"
        "* All rights reserved.                                                      *\n"
        "*                                                                           *\n"
        "* This program is free software; you can redistribute it and/or modify      *\n"
        "* it under the terms of the GNU General Public License as published by      *\n"
        "* the Free Software Foundation; either version 2 of the License, or         *\n"
        "* (at your option) any later version.                                       *\n"
        "*                                                                           *\n"
        "* This program is distributed in the hope that it will be useful,           *\n"
        "* but WITHOUT ANY WARRANTY; without even the implied warranty of            *\n"
        "* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *\n"
        "* GNU General Public License (http://www.gnu.org/licenses/gpl.txt)          *\n"
        "* for more details.                                                         *\n"
        "*                                                                           *\n"
        "*****************************************************************************\n"
        "* Modified by P Marais, 2014                                                *\n"
        "*****************************************************************************/\n"
        "\n"
        "//#version 120\n"
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "// vertex shader data: positions and texture coords only\n"
        "layout (location=0) in vec3 vertex;\n"
        "layout (location=1) in vec2 UV;\n"
        "\n"
        "// transformations\n"
        "uniform mat4 MV; // model-view mx\n"
        "uniform mat4 MVproj; //model-view-projection mx\n"
        "uniform mat3 normMx; // normal matrix\n"
        "\n"
        "//colours and material\n"
        "uniform vec4 surfColour;\n"
        "uniform vec4 ptLightPos1; // for side wall lighting\n"
        "uniform vec4 ptLightPos2;\n"
        "\n"
        "// textures with height and precomputed normals\n"
        "uniform sampler2D normalMap;\n"
        "uniform sampler2D htMap;\n"
        "\n"
        "uniform int drawWalls; // if 0, draw terrain, else drawing walls\n"
        "uniform vec3 normalWall; // if drawing wall vertices, use this normal\n"
        "\n"
        "uniform float terrainBase; // lowest point on terrain\n"
        "uniform float terrainBasePad; // additional height padding to avoid 'thin' terrains\n"
        "\n"
        "//varying vec3  normal;\n"
        "//varying vec3  view;\n"
        "//varying float depth;\n"
        "\n"
        "// need for radiance scaling computations in FS\n"
        "// these wil be interpolated per frag and used\n"
        "// during render to FBO\n"
        "\n"
        "out vec3 normal;\n"
        "out float depth;\n"
        "out vec3 view;\n"
        "out vec4 colour;\n"
        "out vec3 lightDir1; // for side wall lighting\n"
        "out vec3 lightDir2;\n"
        "out vec3 halfVector1;\n"
        "out vec3 halfVector2;\n"
        "\n"
        "// needed for contours\n"
        "out vec3 pos;\n"
        "out vec2 texCoord;\n"
        "\n"
        "void main() {\n"
        "    vec3 inNormal, v;\n"
        "\n"
        "    texCoord = UV;\n"
        "    v = vertex;\n"
        "\n"
        "    // lookup normal in texture\n"
        "    if (drawWalls == 0) // drawing ht field - lookup normals\n"
        "    {\n"
        "        inNormal = texture(normalMap, UV).xyz;\n"
        "        // correct vertex position from heigt map...\n"
        "        v.y = texture(htMap, UV).r;\n"
        "    }\n"
        "    else\n"
        "    {\n"
        "        inNormal = normalWall; // use fixed normal for all wall vertices\n"
        "        if (UV.s < 0.0) // base of wall: must adapt to editing\n"
        "            v.y = terrainBase - terrainBasePad;\n"
        "        else\n"
        "            v.y = texture(htMap, UV).r;\n"
        "    }\n"
        "\n"
        "    pos = v;\n"
        "\n"
        "    // vertex in camera coords\n"
        "    vec4 ecPos = MV * vec4(v, 1.0);\n"
        "\n"
        "//  view   = -(gl_ModelViewMatrix*gl_Vertex).xyz;\n"
        "//  normal = gl_NormalMatrix*gl_Normal;\n"
        "//  depth  = log(-(gl_ModelViewMatrix*gl_Vertex).z);\n"
        "\n"
        "  view   = -ecPos.xyz;\n"
        "  //normal = normalize(inNormal);\n"
        "  normal = normalize(normMx * inNormal);\n"
        "  depth  = log(-ecPos.z);\n"
        "\n"
        "  lightDir1  = normalize(ptLightPos1.xyz - ecPos.xyz);\n"
        "  lightDir2  = normalize(ptLightPos2.xyz - ecPos.xyz);\n"
        "  halfVector1 = normalize(normalize(-ecPos.xyz) + lightDir1);\n"
        "  halfVector2 = normalize(normalize(-ecPos.xyz) + lightDir1);\n"
        "\n"
        "  gl_Position = MVproj * vec4(v, 1.0); // clip space position\n"
        "\n"
        "  colour = surfColour;\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("rad_scaling_pass1.frag",
        "/****************************************************************************\n"
        "* Render Radiance Scaling                                                   *\n"
        "* Meshlab's plugin                                                          *\n"
        "*                                                                           *\n"
        "* Copyright(C) 2010                                                         *\n"
        "* Vergne Romain, Dumas Olivier                                              *\n"
        "* INRIA - Institut Nationnal de Recherche en Informatique et Automatique    *\n"
        "*                                                                           *\n"
        "* All rights reserved.                                                      *\n"
        "*                                                                           *\n"
        "* This program is free software; you can redistribute it and/or modify      *\n"
        "* it under the terms of the GNU General Public License as published by      *\n"
        "* the Free Software Foundation; either version 2 of the License, or         *\n"
        "* (at your option) any later version.                                       *\n"
        "*                                                                           *\n"
        "* This program is distributed in the hope that it will be useful,           *\n"
        "* but WITHOUT ANY WARRANTY; without even the implied warranty of            *\n"
        "* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *\n"
        "* GNU General Public License (http://www.gnu.org/licenses/gpl.txt)          *\n"
        "* for more details.                                                         *\n"
        "*                                                                           *\n"
        "*****************************************************************************\n"
        "* Modified by P Marais, 2014                                                *\n"
        "*****************************************************************************/\n"
        "\n"
        "//#version 120\n"
        "//#extension GL_ARB_draw_buffers : enable\n"
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "uniform int drawWalls;\n"
        "uniform int drawContours;\n"
        "uniform int drawGridLines;\n"
        "uniform int drawWallContours;\n"
        "uniform int drawWallGridLines;\n"
        "\n"
        "uniform int useRegionTexture;\n"
        "uniform int useConstraintTexture;\n"
        "\n"
        "uniform int drawOutOfBounds;\n"
        "uniform float outBoundsMax;\n"
        "uniform float outBoundsMin;\n"
        "uniform float outBoundsBlend;\n"
        "uniform vec4 outBoundsCol;\n"
        "\n"
        "uniform sampler2D overlayTexture;\n"
        "uniform sampler2D constraintTexture;\n"
        "\n"
        "in vec3 lightDir1; // for side wall lighting\n"
        "in vec3 lightDir2;\n"
        "in vec3 halfVector1;\n"
        "in vec3 halfVector2;\n"
        "\n"
        "in vec3  normal;\n"
        "in vec3  view;\n"
        "in float depth;\n"
        "in vec4 colour;\n"
        "\n"
        "in vec3 pos;\n"
        "in vec2 texCoord;\n"
        "\n"
        "layout (location = 0) out vec4 grad;\n"
        "layout (location = 1) out vec4 norm;\n"
        "layout (location = 2) out vec4 col;\n"
        "\n"
        "// contour and grid line params\n"
        "uniform float gridColFactor;\n"
        "uniform float gridX;\n"
        "uniform float gridZ;\n"
        "uniform float gridThickness;\n"
        "uniform float contourSep;\n"
        "uniform float contourThickness;\n"
        "uniform float contourColFactor;\n"
        "\n"
        "void main(void) {\n"
        "  const float eps = 0.01;\n"
        "  const float foreshortening = 0.4;\n"
        "\n"
        "  vec3 n = normalize(normal);\n"
        "\n"
        "  float gs  = n.z<eps ? 1.0/eps : 1.0/n.z;\n"
        "\n"
        "  gs = pow(gs,foreshortening);\n"
        "\n"
        "  float gx  = -n.x*gs;\n"
        "  float gy  = -n.y*gs;\n"
        "\n"
        "  grad = vec4(gx,gy,depth,1.0);\n"
        "  norm = vec4(n,gl_FragCoord.z);\n"
        "\n"
        "  // do nota pply radiance scaling to walls\n"
        "  if (drawWalls == 1)\n"
        "     norm = vec4(0.0,0.0,0.0,gl_FragCoord.z);\n"
        "\n"
        "  // use texture map for colour if terrain overlay is present\n"
        "\n"
        "  col = (useRegionTexture == 1 ? texture(overlayTexture, texCoord) : colour);\n"
        "\n"
        "  // blend in constraint texture if present:\n"
        "  if (useConstraintTexture == 1)\n"
        "  {\n"
        "      vec4 texel = texture(constraintTexture, texCoord);\n"
        "      col = vec4(mix(col.rgb, texel.rgb, texel.a), col.a);\n"
        "  }\n"
        "\n"
        "  if (drawWalls == 1) // compute ambient + diffuse term 2 opposite point lights\n"
        "  {\n"
        "      col = vec4(colour * ( clamp(dot(n, normalize(lightDir1) ), 0.0,1.0) +\n"
        "                            clamp(dot(n, normalize(lightDir2) ), 0.0,1.0) + 0.3) );\n"
        "  }\n"
        "\n"
        " // draw contours - always draw terrain contours if set, but do not necessarily draw side wall contours\n"
        "\n"
        "  if (drawContours == 1 && (drawWalls == 0 || (drawWallContours == 1 && drawWalls == 1)) )\n"
        "    {\n"
        "        float f  = abs(fract (pos.y*contourSep) - 0.5);\n"
        "        float df = fwidth(pos.y*contourSep);\n"
        "        float g = smoothstep(contourThickness*df, 2.0*contourThickness*df , f);\n"
        "\n"
        "        float c = g;\n"
        "        //col = vec4(c,c,c,1.0) * col + (1-c)*vec4(1.0,0.0,0.0,1.0);\n"
        "        col = vec4(c,c,c,1.0)*col + (1-c)*contourColFactor*col;\n"
        "    }\n"
        "\n"
        "   // draw grid lines, but not on walls\n"
        "   if (drawGridLines == 1 && (drawWalls == 0 || (drawWalls == 1 && drawWallGridLines == 1)) )\n"
        "   {\n"
        "        vec2 f  = abs(fract (vec2(pos.x*gridX, pos.z*gridZ)) - 0.5);\n"
        "        vec2 df = fwidth(vec2(pos.x*gridX, pos.z*gridZ));\n"
        "        vec2 g = smoothstep(gridThickness*df, 2.0*gridThickness*df , f);\n"
        "        float c = g.x * g.y;\n"
        "        col = vec4(c,c,c,1.0)*col + (1-c)*gridColFactor*col;\n"
        "   }\n"
        "\n"
        "   // add in out of bounds colour indication\n"
        "   if (drawOutOfBounds == 1 && drawWalls == 0 && (pos.y > outBoundsMax || pos.y < outBoundsMin) )\n"
        "       col = mix(col, outBoundsCol, outBoundsBlend);\n"
        "\n"
        "   col = clamp(col, 0.0, 1.0);\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("rad_scaling_pass2.vert",
        "/****************************************************************************\n"
        "* Render Radiance Scaling                                                   *\n"
        "* Meshlab's plugin                                                          *\n"
        "*                                                                           *\n"
        "* Copyright(C) 2010                                                         *\n"
        "* Vergne Romain, Dumas Olivier                                              *\n"
        "* INRIA - Institut Nationnal de Recherche en Informatique et Automatique    *\n"
        "*                                                                           *\n"
        "* All rights reserved.                                                      *\n"
        "*                                                                           *\n"
        "* This program is free software; you can redistribute it and/or modify      *\n"
        "* it under the terms of the GNU General Public License as published by      *\n"
        "* the Free Software Foundation; either version 2 of the License, or         *\n"
        "* (at your option) any later version.                                       *\n"
        "*                                                                           *\n"
        "* This program is distributed in the hope that it will be useful,           *\n"
        "* but WITHOUT ANY WARRANTY; without even the implied warranty of            *\n"
        "* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *\n"
        "* GNU General Public License (http://www.gnu.org/licenses/gpl.txt)          *\n"
        "* for more details.                                                         *\n"
        "*                                                                           *\n"
        "*****************************************************************************\n"
        "* Modified by P Marais, 2014                                                *\n"
        "*****************************************************************************/\n"
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "// pass through vertex shader: screen aligned quad\n"
        "// vertex shader data: positions coords only\n"
        "\n"
        "layout (location=0) in vec2 vertex;\n"
        "layout (location=1) in vec2 tcoord;\n"
        "\n"
        "out vec2 texCoord;\n"
        "\n"
        "void main(void) {\n"
        "  texCoord = tcoord;\n"
        "  gl_Position = vec4(vertex.x, vertex.y, 0.0, 1.0); //clip space position - already in clip space\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("rad_scaling_pass2.frag",
        "/****************************************************************************\n"
        "* Render Radiance Scaling                                                   *\n"
        "* Meshlab's plugin                                                          *\n"
        "*                                                                           *\n"
        "* Copyright(C) 2010                                                         *\n"
        "* Vergne Romain, Dumas Olivier                                              *\n"
        "* INRIA - Institut Nationnal de Recherche en Informatique et Automatique    *\n"
        "*                                                                           *\n"
        "* All rights reserved.                                                      *\n"
        "*                                                                           *\n"
        "* This program is free software; you can redistribute it and/or modify      *\n"
        "* it under the terms of the GNU General Public License as published by      *\n"
        "* the Free Software Foundation; either version 2 of the License, or         *\n"
        "* (at your option) any later version.                                       *\n"
        "*                                                                           *\n"
        "* This program is distributed in the hope that it will be useful,           *\n"
        "* but WITHOUT ANY WARRANTY; without even the implied warranty of            *\n"
        "* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *\n"
        "* GNU General Public License (http://www.gnu.org/licenses/gpl.txt)          *\n"
        "* for more details.                                                         *\n"
        "*                                                                           *\n"
        "*****************************************************************************\n"
        "* Modified by P Marais, 2014                                                *\n"
        "*****************************************************************************/\n"
        "//#version 120\n"
        "//#extension GL_EXT_gpu_shader4 : enable\n"
        "#version 150\n"
        "//#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "out vec4 fcolour;\n"
        "\n"
        "in vec2 texCoord;\n"
        "\n"
        "uniform vec2 imgSize;  // used to find frag coordinates for screen aligned quad\n"
        "uniform vec4 lightPos0; // in camera coordinates\n"
        "uniform vec4 lightPos1; // in camera coordinates\n"
        "\n"
        "uniform sampler2D grad;  // (gx,gy,depth,1.0)\n"
        "uniform sampler2D norm;  // (nx,ny,nz,depth)\n"
        "uniform sampler2D colormap; // (r,g,b,1.0)\n"
        "\n"
        "uniform sampler2D manipTTexture; // texture with all manipulator fragments\n"
        "\n"
        "uniform float     sw;\n"
        "uniform float     sh;\n"
        "uniform float     enhancement;\n"
        "uniform float     transition;\n"
        "uniform bool      enabled;\n"
        "uniform bool      invert;\n"
        "uniform int       display;\n"
        "uniform bool      twoLS;\n"
        "uniform sampler2D convexLS;\n"
        "uniform sampler2D concavLS;\n"
        "\n"
        "\n"
        "// **** GRADIENT DATA ****\n"
        "// |A|B|C|\n"
        "// |D|X|E|\n"
        "// |F|G|H|\n"
        "vec4 X,A,B,C,D,E,F,G,H;\n"
        "\n"
        "// **** UTIL FUNCTIONS ****\n"
        "void loadValues() {\n"
        "\n"
        "  //vec2 texCoord = (gl_FragCoord.xy + 0.5 ) / imgSize.xy;\n"
        "\n"
        "  float xc = texCoord.s;\n"
        "  float xm = texCoord.s-sw;\n"
        "  float xp = texCoord.s+sw;\n"
        "\n"
        "  float yc = texCoord.t;\n"
        "  float ym = texCoord.t-sh;\n"
        "  float yp = texCoord.t+sh;\n"
        "\n"
        "  X = texture(grad,vec2(xc,yc));\n"
        "  A = texture(grad,vec2(xm,yp));\n"
        "  B = texture(grad,vec2(xc,yp));\n"
        "  C = texture(grad,vec2(xp,yp));\n"
        "  D = texture(grad,vec2(xm,yc));\n"
        "  E = texture(grad,vec2(xp,yc));\n"
        "  F = texture(grad,vec2(xm,ym));\n"
        "  G = texture(grad,vec2(xc,ym));\n"
        "  H = texture(grad,vec2(xp,ym));\n"
        "}\n"
        "\n"
        "vec3 hsvToRgb(in float h,in float s,in float v) {\n"
        "  vec3 color;\n"
        "  int hi = int(floor(h/60.0))%6;\n"
        "  float f = h/60.0 - floor(h/60.0);\n"
        "  float p = v*(1.0-s);\n"
        "  float q = v*(1.0-f*s);\n"
        "  float t = v*(1.0-(1.0-f)*s);\n"
        "\n"
        "  if(hi==0) color = vec3(v,t,p);\n"
        "  else if(hi==1) color = vec3(q,v,p);\n"
        "  else if(hi==2) color = vec3(p,v,t);\n"
        "  else if(hi==3) color = vec3(p,q,v);\n"
        "  else if(hi==4) color = vec3(t,p,v);\n"
        "  else color = vec3(v,p,q);\n"
        "\n"
        "  return color;\n"
        "}\n"
        "\n"
        "float tanh(in float c, in float en) {\n"
        "  float cmax = en*15.0;\n"
        "  const float tanhmax = 3.11622;\n"
        "\n"
        "  float x = ((c*cmax*1.0)/tanhmax);\n"
        "  float e = exp(-2.0*x);\n"
        "  float t = clamp((1.0-e)/(1.0+e),-1.0,1.0);\n"
        "\n"
        "  return t;\n"
        "}\n"
        "\n"
        "// **** WARPING FUNCTION ****\n"
        "float warp(in float impfunc,in float beta) {\n"
        "  const float alpha = 0.1;\n"
        "  float expbeta = exp(-beta);\n"
        "  return (alpha*expbeta+impfunc*(1.0-alpha-alpha*expbeta)) / (alpha+impfunc*(expbeta-alpha-alpha*expbeta));\n"
        "}\n"
        "\n"
        "// **** WEIGHT FUNCTIONS ****\n"
        "float silhouetteWeight(in float s) {\n"
        "  const float ts = 0.07;\n"
        "  const float t2 = 0.9+ts;\n"
        "  const float t1 = t2-0.01;\n"
        "\n"
        "  return smoothstep(t1,t2,max(1.0-s,0.9));\n"
        "}\n"
        "\n"
        "float weight() {\n"
        "  return (silhouetteWeight(abs(A.z-X.z)) +\n"
        "      silhouetteWeight(abs(B.z-X.z)) +\n"
        "       silhouetteWeight(abs(C.z-X.z)) +\n"
        "       silhouetteWeight(abs(D.z-X.z)) +\n"
        "       silhouetteWeight(abs(E.z-X.z)) +\n"
        "       silhouetteWeight(abs(F.z-X.z)) +\n"
        "       silhouetteWeight(abs(G.z-X.z)) +\n"
        "       silhouetteWeight(abs(H.z-X.z)))/8.0;\n"
        "}\n"
        "\n"
        "// **** CURVATURE FUNCTIONS ****\n"
        "vec3 hessian() {\n"
        "  float xx = E.x-D.x;\n"
        "  float xy = E.y-D.y;\n"
        "  float yx = B.x-G.x;\n"
        "  float yy = B.y-G.y;\n"
        "\n"
        "  return vec3(xx,yy,(xy+yx)/2.0);\n"
        "}\n"
        "\n"
        "float curvature(in float w, in vec3 h, in float e) {\n"
        "  float c = tanh(-(h.x+h.y)/2.0,e);\n"
        "  return invert ? -c*max(w-0.5,0.0) : c*max(w-0.5,0.0);\n"
        "}\n"
        "\n"
        "// **** DESCRIPTOR FUNCTIONS ****\n"
        "vec4 coloredDescriptor(in float c, in float s) {\n"
        "  vec3 rgb;\n"
        "  vec3 convMax = vec3(0.1,0.1,0.8);\n"
        "  vec3 convMin = vec3(0.2,0.2,0.6);\n"
        "  vec3 concMax = vec3(0.8,0.1,0.1);\n"
        "  vec3 concMin = vec3(0.6,0.2,0.2);\n"
        "  vec3 plane   = vec3(0.7,0.7,0.2);\n"
        "  float t = 0.02;\n"
        "  float a;\n"
        "\n"
        "  if(c<-t) {\n"
        "    a = (-c-t)/(1.0-t);\n"
        "    rgb = mix(concMin,concMax,a);\n"
        "  } else if(c>t) {\n"
        "    a = (c-t)/(1.0-t);\n"
        "    rgb = mix(convMin,convMax,a);\n"
        "  } else if(c<0.0) {\n"
        "    a = -c/t;\n"
        "    rgb = mix(plane,concMin,a);\n"
        "  } else {\n"
        "    a = c/t;\n"
        "    rgb = mix(plane,convMin,a);\n"
        "  }\n"
        "\n"
        "  if(s<1.0)\n"
        "    rgb = vec3(0.2);\n"
        "\n"
        "  return vec4(rgb,1.0);\n"
        "}\n"
        "\n"
        "vec4 greyDescriptor(in float c, in float s) {\n"
        "  return vec4((c*0.5+0.5)-(1.0-s));\n"
        "}\n"
        "\n"
        "// **** LIT SPHERE FUNCTIONS ****\n"
        "vec4 oneLitSphere(in vec3 n,in float c) {\n"
        "  vec4 color = texture(convexLS,(n.xy*0.5)+vec2(0.5));\n"
        "\n"
        "  return enabled ? color*warp(length(color),c) : color;\n"
        "}\n"
        "\n"
        "vec4 twoLitSphere(in vec3 n,in float w,in vec3 h,in float c) {\n"
        "  const float eps = 0.2;\n"
        "\n"
        "  vec2 coord = (n.xy*0.5)+vec2(0.5);\n"
        "  vec4 cconv = texture(convexLS,coord);\n"
        "  vec4 cconc = texture(concavLS,coord);\n"
        "  vec4 color = mix(cconc,cconv,smoothstep(0.5-eps,0.5+eps,curvature(w,h,transition)*0.5+0.5));\n"
        "\n"
        "  return enabled ? color*warp(length(color),c) : color;\n"
        "}\n"
        "\n"
        "// **** LIGHTING COMPUTATION ****\n"
        "void main(void) {\n"
        "\n"
        "   //vec2 texCoord = (gl_FragCoord.xy + 0.5 ) / imgSize.xy;\n"
        "\n"
        "  vec3 n = texture(norm, texCoord.st).xyz;\n"
        "\n"
        "  if(n==vec3(0.0)) { // fragments outside mesh or that we do not want affected by RS\n"
        "    fcolour = vec4(texture(colormap, texCoord.st).xyz,1.0);\n"
        "\n"
        "    return;\n"
        "  }\n"
        "\n"
        "  // data\n"
        "  loadValues();\n"
        "  float w = weight();\n"
        "  vec3  h = hessian();\n"
        "  float c = curvature(w,h,enhancement);\n"
        "\n"
        "// Q? this assumes a directional light?\n"
        "  vec3  l0 = normalize(lightPos0.xyz);\n"
        "  vec3  l1 = normalize(lightPos1.xyz);\n"
        "  vec4  m = vec4(texture(colormap, texCoord.st).xyz,1.0);\n"
        "\n"
        "  //Initialize the depth of the fragment with the just saved depth\n"
        "  gl_FragDepth = texture(norm, texCoord.st).w;\n"
        "\n"
        "  if(display==0)\n"
        "  {\n"
        "    // lambertian lighting + ambient (white light source assumed)\n"
        "    // diffuse dirnl light 0:\n"
        "    float cosineTerm = max(dot(n,l0),0.0);\n"
        "    float warpedTerm = enabled ? (0.6*cosineTerm*warp(cosineTerm,c) + 0.2*warp(1.0,c) ) : (0.6*cosineTerm + 0.2);\n"
        "    fcolour = m*warpedTerm;\n"
        "    // diffuse dirnl light 1:\n"
        "    cosineTerm = max(dot(n,l1),0.0);\n"
        "    warpedTerm = enabled ? (0.6*cosineTerm*warp(cosineTerm,c) ) : (0.6*cosineTerm);\n"
        "    fcolour += m*warpedTerm;\n"
        "    // blend in hidden manipulators\n"
        "    vec4 texel = texture(manipTTexture, texCoord.st);\n"
        "    fcolour = vec4(mix(fcolour.rgb, texel.rgb, texel.a), fcolour.a);\n"
        "  }\n"
        "  else if(display==1)\n"
        "  {\n"
        "    // using lit spheres\n"
        "    if(twoLS) {\n"
        "      fcolour = twoLitSphere(n,w,h,c);\n"
        "    } else {\n"
        "      fcolour = oneLitSphere(n,c);\n"
        "    }\n"
        "  }\n"
        "  else if(display==2)\n"
        "  {\n"
        "    // colored descriptor\n"
        "    fcolour = coloredDescriptor(c,w);\n"
        "  }\n"
        "  else if(display==3)\n"
        "  {\n"
        "    // grey descriptor\n"
        "    fcolour = greyDescriptor(c,w);\n"
        "  }\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("texmark.cl",
        "__constant sampler_t directSampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_NEAREST;\n"
        "\n"
        "inline float sample(__read_only image2d_t image, int2 pos)\n"
        "{\n"
        "    float4 v = read_imagef(image, directSampler, pos);\n"
        "    return v.x + v.y + v.z + v.w;\n"
        "}\n"
        "\n"
        "__kernel void benchmark2d(__read_only image2d_t image, __global uint *out)\n"
        "{\n"
        "    int2 gid = (int2) (get_global_id(0), get_global_id(1)) ADDR_MODIFIER;\n"
        "    float sum = sample(image, gid);\n"
        "    sum += sample(image, gid + (int2) (5, 5));\n"
        "    sum += sample(image, gid + (int2) (10, 10));\n"
        "    sum += sample(image, gid + (int2) (-5, 5));\n"
        "    sum += sample(image, gid + (int2) (5, -5));\n"
        "    sum += sample(image, gid + (int2) (0, 20));\n"
        "    sum += sample(image, gid + (int2) (0, -20));\n"
        "    sum += sample(image, gid + (int2) (-20, 0));\n"
        "    sum += sample(image, gid + (int2) (20, 0));\n"
        "\n"
        "    volatile float sink = sum;\n"
        "}\n"
    ),

};

const uts::unordered_map<uts::string, uts::string> &getSourceMap()
{
    return g_sources;
}

const uts::string &getSource(const uts::string &filename)
{
    auto pos = g_sources.find(filename);
    if (pos == g_sources.end())
        throw std::invalid_argument("Source " + filename + " not found");
    return pos->second;
}

